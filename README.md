## unsafe.c 的问题
### 1. 竞态条件
当多个线程（如t1和t2）同时访问和修改同一个共享资源（全局变量`counter`）时，由于线程调度的不确定性，会导致执行结果依赖于线程执行的顺序，这种现象称为**竞态条件**

### 2. `counter++`的非原子性
`counter++`这行看似简单的语句，在底层并非原子操作（不可分割的最小单位）。它实际上对应三条机器指令[2,4](@ref)：
1.  **读取**：将`counter`的值从内存加载到CPU寄存器。
2.  **修改**：在寄存器中将值加1。
3.  **写入**：将新值写回`counter`的内存地址。


## mutex.c 

### 互斥锁的使用原则
1. **临界区最小化**：仅保护共享数据的访问代码，避免在临界区内执行耗时操作（如I/O）[6](@ref)。
2. **锁的配对**：确保每个 `lock` 都有对应的 `unlock`，防止死锁 [6](@ref)。
3. **错误处理**：实际应用中应检查锁函数的返回值（如 `EAGAIN`、`EDEADLK`）[1](@ref)。

### 其他同步机制
- **条件变量（Condition Variables）**：用于线程间通知（如生产者-消费者模型）[2,6](@ref)。
- **自旋锁**：适用于临界区极短且线程阻塞成本高的场景。

## 深入理解自旋锁的“忙等待”
自旋锁的核心在于“忙等待”（Busy-waiting）。当一个线程尝试获取一个已经被占用的自旋锁时，它不会像互斥锁那样立刻被系统挂起，而是执行一个紧凑的循环，不断地尝试获取锁，直到成功为止
。这个过程可以通俗地理解为：“我不睡，我就在这儿等着，你一用完我马上接手。”
