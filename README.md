## unsafe.c 的问题
### 1. 竞态条件
当多个线程（如t1和t2）同时访问和修改同一个共享资源（全局变量`counter`）时，由于线程调度的不确定性，会导致执行结果依赖于线程执行的顺序，这种现象称为**竞态条件**

### 2. `counter++`的非原子性
`counter++`这行看似简单的语句，在底层并非原子操作（不可分割的最小单位）。它实际上对应三条机器指令[2,4](@ref)：
1.  **读取**：将`counter`的值从内存加载到CPU寄存器。
2.  **修改**：在寄存器中将值加1。
3.  **写入**：将新值写回`counter`的内存地址。


## mutex.c 

### 互斥锁的使用原则
1. **临界区最小化**：仅保护共享数据的访问代码，避免在临界区内执行耗时操作（如I/O）[6](@ref)。
2. **锁的配对**：确保每个 `lock` 都有对应的 `unlock`，防止死锁 [6](@ref)。
3. **错误处理**：实际应用中应检查锁函数的返回值（如 `EAGAIN`、`EDEADLK`）[1](@ref)。

### 其他同步机制
- **条件变量（Condition Variables）**：用于线程间通知（如生产者-消费者模型）[2,6](@ref)。
- **自旋锁**：适用于临界区极短且线程阻塞成本高的场景。

## 深入理解自旋锁的“忙等待”
自旋锁的核心在于“忙等待”（Busy-waiting）。当一个线程尝试获取一个已经被占用的自旋锁时，它不会像互斥锁那样立刻被系统挂起，而是执行一个紧凑的循环，不断地尝试获取锁，直到成功为止。这个过程可以通俗地理解为：“我不睡，我就在这儿等着，你一用完我马上接手。”

## spinlock.c    自旋锁使用关键注意事项

### 1. ⚠️ 适用场景限制

自旋锁主要适用于**锁持有时间极短**的场景（通常仅包含几条指令），例如对简单标志位的修改或整数的原子递增[1,8](@ref)。它的核心思想是，如果锁被占用的时间非常短，那么等待锁的线程通过“忙等待”（Busy-waiting）来避免操作系统进行线程上下文切换的开销，其性能会高于互斥锁[7,9](@ref)。

**在您的代码中，临界区内包含了 `usleep(1)` 调用，这会使线程主动休眠。** 这将导致其他尝试获取锁的线程长时间处于自旋状态，持续空转并**严重浪费CPU资源**，使得自旋锁在此场景下变得极不适用[1,4](@ref)。

### 2. 🔄 自旋锁与互斥锁的选择

基于您的代码特点（临界区中包含休眠操作），下表对比了两种锁的差异，并给出了明确建议。

| 特性 | 自旋锁 (Spinlock) | 互斥锁 (Mutex) | 对您当前场景的评估 |
| :--- | :--- | :--- | :--- |
| **等待机制** | **忙等待**：线程循环检查锁状态，不释放CPU[1,9](@ref)。 | **休眠等待**：线程被挂起，让出CPU给其他线程[8,9](@ref)。 | **有关键区休眠，适合互斥锁的休眠机制**。 |
| **性能开销** | 获取锁失败时**无上下文切换开销**，但会**持续消耗CPU周期**[8](@ref)。 | 获取锁失败时有**两次上下文切换开销**（挂起和唤醒），但等待时不占CPU[9](@ref)。 | 休眠时间长，自旋锁的忙等待将导致大量CPU资源浪费，**互斥锁更优**。 |
| **适用场景** | 锁持有时间**极短**（纳秒/微秒级）、多核处理器、**不允许睡眠的上下文**（如中断处理）[1,5](@ref)。 | 锁持有时间**较长**、临界区可能包含**阻塞操作**（如I/O、休眠）[8,9](@ref)。 | 临界区明确包含 `usleep`，**必须使用互斥锁**。 |
| **风险警示** | 在持有锁的临界区内**绝对不能调用可能引起睡眠或阻塞的函数**（如 `kmalloc`, `copy_from_user`），否则极易导致死锁[2,5](@ref)。 | 允许在临界区内进行可能导致线程切换的操作。 | 当前代码在锁内使用 `usleep`，若使用自旋锁**有死锁风险**。 |

### 3. 💡 结论与行动建议

**强烈建议您将当前程序中的自旋锁替换为互斥锁。**

互斥锁能够很好地处理临界区中存在延时或休眠的情况。在POSIX线程（pthreads）中，互斥锁可以静态初始化，使用起来非常方便：





